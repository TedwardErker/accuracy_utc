#+TITLE:Accuracy and Spatial Scale
#+AUTHOR: Tedward Erker
#+email: erker@wisc.edu
#+PROPERTY: header-args:R :session *R* :cache no :results output :exports both :tangle yes
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:nil reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:850
#+OPTIONS: toc:nil
#+REVEAL_TRANS:fade
#+REVEAL_MARGIN: 0.01
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_THEME: solarized
#+REVEAL_HEAD_PREAMBLE: <meta name="description" content="Data visualization.">
#+REVEAL_POSTAMBLE: <p> Created by Erker </p>
#+PROPERTY: session *R*
#+PROPERTY: cache yes
#+PROPERTY: exports both
#+PROPERTY: tangle yes

------------
* Pre [2016-11-11 Fri]
** DONE make smaller spaces shapefile and send to Andy and Grady <2016-04-12 Tue>
** load libraries
#+BEGIN_SRC R :exports none :results none
  library(doParallel)
  library(gridExtra)
    library(maptools)
    library(spatstat)
    library(sp)
    library(rgeos)
    library(foreach)
    library(doParallel)
  library(ascii)
  library(broom)
  library(plyr)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(ggplot2)
  options(asciiType = "org")
  org.ascii <- function(x) {
    suppressWarnings(ascii(x))
  }
#+END_SRC

** Motivation:

Due to misregistration in high resolution images, pixel-wise accuracy
may be low.  But at the larger scales at which endusers will perform
analysis and make decisions, accuracy may be higher.

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f8.png :eval no
  mean.crown.dia <- 20
  n.stems <- 3
  x <- runif(n = n.stems, min = x.min, max = x.max)
  y <- runif(n = n.stems, min = y.min, max = y.max)

                                            # make strems sp object
        xy <- data.frame(x,y)
        xy.sp <- SpatialPoints(xy)
      plot(xy.sp)


                                            # add crown to stems
            pol <- gBuffer(xy.sp, width = mean.crown.dia)
            pol <- spChFIDs(pol, x = as.character(i))

           plot(pol)


                                            # create tree spatial polygon

        tree.sp <- gUnionCascaded(pol)
        plot(tree.sp)

# misregistered tree

  x.mis <- x + rnorm(n = n.stems, sd = 6)
  y.mis <- y + rnorm(n = n.stems, sd = 6)

  xy <- data.frame(x.mis,y.mis)
        xy.sp <- SpatialPoints(xy)

                                            # add crown to stems
            pol <- gBuffer(xy.sp, width = mean.crown.dia)
            pol <- spChFIDs(pol, x = as.character(i))

                                            # create tree spatial polygon

        tree.sp.misregistered <- gUnionCascaded(pol)
        plot(tree.sp.misregistered)

  tree.sp.fort <- fortify(tree.sp) %>% rename(x = long, y = lat)
  tree.sp.mis.fort <- fortify(tree.sp.misregistered) %>% rename(x = long, y = lat)

  tree <- ggplot() +
      geom_polygon(data = tree.sp.fort, aes(x = x, y = y, group = group), fill = "#7fc97f") +
      coord_equal()

  tree.mis <- ggplot() +
      geom_polygon(data = tree.sp.mis.fort, aes(x = x, y = y, group = group), fill = "#7fc97f") +
      coord_equal()

  grid.arrange(tree,tree.mis, ncol = 2)
#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f8.png]]


** Questions:

1) How does the accuracy of a classified image change as spatial scale at which accuracy is assessed increases?

2) Can I develop a method to report accuracies at different scales?


** If starting from scratch:

1) Select ~30 regions at each of the spatial scales of interest randomly across map.
2) Drop X number of points randomly within each region and identify
   their class (from google earth).  Calculate the % cover for each class.
3) Calculate the % cover for each region using the classified image
4) Calculate the difference in % Cover as estimated from google earth
   and from the classified image
5) Fit model with region size a predictor and error as response to
   test for effect and report how error changes with spatial scale


** However, what I'm working with now is different

What I've done up to now is lazier.  The shortcuts have their
benefits, but I need to make sure I account for possible bias or
dependence.

*** What I did:

1) Drop 60 grids of points randomly on the image.
   1) Grids range from 50mx50m to 200mx200m
   2) distance between points is about 7m
2) Identify the cover class below each point in google earth
3) Starting in the north-west corner of the grids, subset the points
   into smaller grids (2x2 - 4 points, 3x3 - 9 points, 4x4 - 16 points, etc.)
4) Calculate percent cover from these subsets of points
5) Calculate the percent cover from the classified image in the region
   below these points (the square region formed by points with a 3.5m buffer)
6) Find the difference in percent cover estimates
7) See how the difference in percent cover estimates changes as the
   size of the grid increases.

The estimate of percent cover from google earth should probably be a
95% CI.


** Simulate process of using grid of points to estimate cover
*** Define Function "test.grid.estimation.accuracy"
#+BEGIN_SRC R
  test.grid.estimation.accuracy <- function(stem.density,
           mean.crown.dia,
           x.min,
           x.max,
           y.min,
           y.max,
           dist.bw.pts,
           n.row.col.sub = c(2,4,6,8,10,12),
           plot = T) {

                                          # generate derived variables
      region_area <- (x.max-x.min)*(y.max-y.min)
      n.row.col.pts <- ((x.max-x.min)/dist.bw.pts) - 1



                                          # generate number of stems

      n.stems <- rpois(n = 1, lambda = region_area * stem.density)


                                          # generate locations of stems

      x <- runif(n = n.stems, min = x.min, max = x.max)
      y <- runif(n = n.stems, min = y.min, max = y.max)


                                          # make strems sp object
      xy <- data.frame(x,y)
      xy.sp <- SpatialPoints(xy)
  #    plot(xy.sp)


                                          # add crown to stems

      xy.pol <- foreach(i = 1:length(xy.sp)) %do% {
         # https://stat.ethz.ch/pipermail/r-help/2005-May/070678.html
          U <- runif(1)
          t <- -log(1- U*(1-exp(-mean.crown.dia)))
          T1<-(mean.crown.dia - t)
          wid <- rpois(n = 1, lambda = T1)+1

          pol <- gBuffer(xy.sp[i,], width = wid)
          pol <- spChFIDs(pol, x = as.character(i))
      }

      pol <- do.call("rbind", xy.pol)
   #   plot(pol)


                                          # create tree spatial polygon

      tree.sp <- gUnionCascaded(pol)
    #  plot(tree.sp)

                                          # these aren't technically unique, maybe need to think about how to actually make it unique
                                          # because there is a very small chance, but a chance, that two tree realizations could have same ID

   # unique id for this realization of tree cover
  tree.sp.id <- paste0(round(runif(1,0,10000)), gArea(tree.sp)) %>% as.numeric()

                                          # create grid of points

      points <- expand.grid(x = dist.bw.pts * 1:n.row.col.pts, y = dist.bw.pts * 1:n.row.col.pts) %>%
          data.frame()

      points.sp <- SpatialPoints(points)

                                          # For each subset of the grid, calculate covers

      res <- foreach(n.row.col.subset = n.row.col.sub, .combine = "rbind") %do% {
          min.max <- c(dist.bw.pts/2, (n.row.col.subset * dist.bw.pts) + .5*dist.bw.pts)
          box <- expand.grid(x = min.max, y = min.max)
          box <- box[chull(box),]

          box.p <- Polygon(box)
          box.ps <- Polygons(list(box.p),1)
          box.sp <- SpatialPolygons(list(box.ps))
                                          #plot(box.sp)

          area.box <- gArea(box.sp)
          tree.in.box <- gIntersection(box.sp, tree.sp)
          if(!is.null(tree.in.box)) {
              area.tree.in.box <- gArea(tree.in.box)
          } else {
              area.tree.in.box <- 0
          }

          true.cover.in.box <- area.tree.in.box / area.box

          if(!is.null(tree.in.box)) {
              n.points.in.tree.in.box <- length(gIntersection(points.sp, tree.in.box))
          } else {

              n.points.in.tree.in.box <- 0
          }


          n.points <- n.row.col.subset^2

          estimated.cover.from.points <- n.points.in.tree.in.box / n.points


          out <- c(n.points = n.points,
                   box.area = area.box,
                   stem.density = stem.density,
                   mean.crown.dia = mean.crown.dia,
                   true.cover.in.box = true.cover.in.box,
            estimated.cover.from.points = estimated.cover.from.points,
           tree.realization.id = tree.sp.id)


# Plot

          if(plot == T) {
              tree.sp.fort <- fortify(tree.sp) %>%
                  rename(x = long, y = lat)

              box.sp.fort <- fortify(box.sp) %>%
                  rename(x = long, y = lat)


              rounded.true.cover <- round(true.cover.in.box,3)
              rounded.est.cover <-  round(estimated.cover.from.points,3)

              png(paste0("../Pjt_acc/figs/sims/",stem.density,"_",tree.sp.id,"_",str_pad(area.box, 5, pad = "0"),".png"))
              p <- ggplot(data = tree.sp.fort, aes(x = x, y = y)) +
                  geom_polygon(data = tree.sp.fort[tree.sp.fort$id %in% tree.sp.fort[tree.sp.fort$hole,]$id,],fill = "#7fc97f", aes(group = group)) +
                  geom_polygon(data = tree.sp.fort[!tree.sp.fort$id %in% tree.sp.fort[tree.sp.fort$hole,]$id,],fill = "#7fc97f", aes(group = group)) +
                  coord_equal() +
                  coord_cartesian(ylim=c(-10, 110), xlim = c(-10,110)) +
                  geom_point(data = points, aes(x = x, y = y)) +
                  geom_polygon(data = box, aes(x = x, y = y), alpha = .3, fill = "#beaed4") +
                  geom_path(data = box.sp.fort, color = "black") +
                  theme_bw() +
                  annotate("text",
                           label = paste0("True Cover in Box: ",rounded.true.cover, "\n",
                                          "Estimated Cover by points: ",rounded.est.cover),
                           x = mean(c(x.min,x.max)), y = y.max, size = 8, colour = "#f0027f") +
                  annotate("text",
                           label = paste0("deviation: ", round(rounded.true.cover - rounded.est.cover,3)),
                           x = mean(c(x.min,x.max)), y = y.min, size = 8, colour = "#f0027f")
              print(p)
              dev.off()
          }
          out
      }

      res <- data.frame(res)

  return(res)
  }
#+END_SRC

#+RESULTS:

*** test grid estimation
#+BEGIN_SRC R :eval no
    x.min <- 0
    x.max <- 100
    y.min <- 0
    y.max <- 100

    dist.bw.pts <- 7


                                            # Simple test run of function

    ## test.grid.estimation.accuracy(stem.density = stem.density,
    ##                               mean.crown.dia = mean.crown.dia,
    ##                               x.min = x.min,
    ##                               x.max = x.max,
    ##                               y.min = y.min,
    ##                               y.max = y.max,
    ##                               dist.bw.pts = dist.bw.pts)


    out.df <- foreach(stem.den = c(.001,.003,.005,.007,.009,.011, .013), .combine = "rbind") %do% {
        foreach(mean.crown.dia = c(5), .combine = "rbind") %do% {
                rep <- replicate(n = 100, test.grid.estimation.accuracy(stem.density = stem.den,
                                  mean.crown.dia = mean.crown.dia,
                                  x.min = x.min,
                                  x.max = x.max,
                                  y.min = y.min,
                                  y.max = y.max,
                                  dist.bw.pts = dist.bw.pts,
                                  plot = F),
                                 simplify = F)
                out <- bind_rows(rep)
                return(out)
            }
        }

    out.df <- out.df %>%
        mutate(error = true.cover.in.box - estimated.cover.from.points)

  saveRDS(out.df, file = "../Pjt_acc/out.rds")

#+END_SRC

#+RESULTS[8f86489e2c118d85341be360fd9864bc7cc6f986]:

#+BEGIN_SRC R :eval no
out.df <- readRDS("../Pjt_acc/out.rds")
#+END_SRC

** Plots

#+BEGIN_SRC R :results raw :eval no

  figs <- list.files(path = "../Pjt_acc/figs/sims/",  full.names = T)

  figs <- figs[1:50]

  out <- sapply(figs, function(fig) message("** [[file:", fig, "]]"))

#+END_SRC

#+RESULTS:
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_55789.2419614318_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.001_6899883.95146242_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_34152724.6073636_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.003_61402326.8657661_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_87482826.3786492_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.005_93393661.4760753_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_29115170.413594_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_00784.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_01764.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_03136.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_04900.png]]
*** [[file:../Pjt_acc/figs/sims//0.007_55514937.6659549_07056.png]]
*** [[file:../Pjt_acc/figs/sims//0.009_40556431.804912_00196.png]]
*** [[file:../Pjt_acc/figs/sims//0.009_40556431.804912_00784.png]]


** Other Plots

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f1.png
  ggplot(out.df, aes(x = true.cover.in.box, y = error)) + geom_point() + facet_grid(~n.points)
#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f1.png]]

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f2.png
  ggplot(out.df, aes(x = true.cover.in.box, y = abs(error))) + geom_point() + facet_grid(~n.points)

#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f2.png]]


#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f3.png
  ggplot(out.df, aes(x = true.cover.in.box, y = estimated.cover.from.points,
                     color = stem.density)) + geom_point(alpha = .1) +
      coord_equal() +
      facet_wrap(~n.points)
#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f3.png]]

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f4.png
  ggplot(out.df, aes(x = true.cover.in.box, y = estimated.cover.from.points)) + geom_point(alpha = .1) +
      geom_density2d() +
      coord_equal() +
      facet_grid(stem.density~n.points)
#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f4.png]]

The 100 realizations of the same stem density on the x axis. Shows
that there is correlation within grids between error rates of
different box/grid sizes.

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f5.png :height 2000
  # Errors are dependent on which tree realization it is
  ggplot(out.df, aes(x = factor(tree.realization.id), y = error)) + geom_boxplot() +
      facet_wrap(~stem.density, ncol = 1, scales = "free")

#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f5.png]]


*** To what degree does this grid sampling deviate from a standard binomial distribution?
#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f6.png

  binomial.df <- foreach(s = c(4,16,36,64,100,144), .combine = "rbind") %do% {
      foreach(p = seq(0,1,.05), .combine = "rbind") %do% {
          phat <- rbinom(n = 100, size = s, prob = p)/s
          df <- data.frame(phat = phat, n.pts = s, prob = p)
      }
  } %>% data.frame

  ggplot(binomial.df, aes(x = prob, y = phat)) + geom_point(alpha = .1) +
      coord_equal() +
      facet_grid(~n.pts)



#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/f6.png]]


#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/f7.png

#+END_SRC





There is clear dependence in the error within a grid.

ALso the grid is regular, but this is required to get the
same number of points per unit area.

For a non-spatial binomial distribution, the sample size reduces
variance.  How might spatial extent affect the variance of the
estimate of p?

points/area is the same, but number of points is not

Why square instead of another shape?


** How well does placing the grid on a landscape estimate cover?
How does stem density and crown width which affect true cover, affect
the accuracy of this estimate?

** Calculating VAR(p1 -p2)

#+BEGIN_SRC R

    n2 <- 225

    out.mat <- foreach(pt = seq(.1,.9,.1), .combine = "rbind") %do% {
       foreach(n1 = seq(4,n2, 10), .combine = "rbind") %do% {
           samp.n <- 10000

           x1 <- rbinom(n = samp.n, size = n1, p = pt)
           p1 <- x1/n1

           xd <- rbinom(n = samp.n, size = (n2-n1), p = pt)
           p2 <- (x1+xd)/n2

           vp1<-var(p1)
           vp2<-var(p2)
           cvp1p2<-cov(x=p1,y=p2)
           vp2.m.vp1 = sum(c(vp1, vp2, 2* cvp1p2))
           cor.p1.p2 <- cor(p1,p2)
           c(true.p = pt, prop.n1.to.n2 = (n1/n2), var.phat1 = vp1, var.phat2 = vp2, cov.phat1.phat2 = cvp1p2, cor.phat1.phat2 = cor.p1.p2, var.p2.minus.p1 = vp2.m.vp1)
       }
    }

#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :eval no

    n2 <- 100

    out.mat <- foreach(pt = seq(.1,.9,.1), .combine = "rbind") %do% {
       foreach(n1 = seq(10,n2, 10), .combine = "rbind") %do% {
           samp.n <- 10000

           x1 <- rbinom(n = samp.n, size = n1, p = pt)
           p1 <- x1

           xd <- rbinom(n = samp.n, size = (n2-n1), p = pt)
           p2 <- (x1+xd)

           vp1<-var(p1)
           vp2<-var(p2)
           cvp1p2<-cov(x=p1,y=p2)
           vp2.m.vp1 = sum(c(vp1, vp2, 2* cvp1p2))
           cor.p1.p2 <- cor(p1,p2)
           c(true.p = pt, prop.n1.to.n2 = (n1/n2), var.phat1 = vp1, var.phat2 = vp2, cov.phat1.phat2 = cvp1p2, cor.phat1.phat2 = cor.p1.p2, var.p2.minus.p1 = vp2.m.vp1)
       }
    }

#+END_SRC
#+RESULTS:


#+BEGIN_SRC R
  out <- data.frame(out.mat)
  out.g <- gather(out, key = var.cov, value = value, -true.p, -prop.n1.to.n2)
  out.g %>% head()
#+END_SRC

#+RESULTS:
#+begin_example
Warning message:
In data.row.names(row.names, rowsi, i) :
  some row.names duplicated: 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207 --> row.names NOT used

 true.p prop.n1.to.n2   var.cov       value
1    0.1    0.01777778 var.phat1 0.022418036
2    0.1    0.06222222 var.phat1 0.006430185
3    0.1    0.10666667 var.phat1 0.003774855
4    0.1    0.15111111 var.phat1 0.002647883
5    0.1    0.19555556 var.phat1 0.002081085
6    0.1    0.24000000 var.phat1 0.001689361
#+end_example

#+BEGIN_SRC R :exports results :results graphics :file ../Pjt_acc/figs/explore.pVar.png

  out.g.no.cor <- filter(out.g, var.cov != "cor.phat1.phat2")

  ggplot(out.g.no.cor, aes(x = prop.n1.to.n2, y = value, color = var.cov)) + geom_line() +
  facet_wrap(~true.p)

  ggplot(filter(out.g, var.cov != "var.phat1"), aes(x = prop.n1.to.n2, y = value, color = var.cov)) + geom_line() +
  facet_wrap(~true.p)


#+END_SRC

#+RESULTS:
[[file:../Pjt_acc/figs/explore.pVar.png]]

* Objective
We want to test how the accuracy of the map changes with spatial
scale.  As we consider larger and larger areas, how does the agreement
between percent canopy cover as estimated by human interpretation of
google earth imagery and as estimated by the map change?

* Plan
At a given location, there are three values that I'm interested in.  p
is the true proportion of canopy cover as seen in reference (in this
case google earth imagery).  p_hat_hum is the estimate of
p that is derived from human interpretation of google earth imagery
over the location.  p_hat_map is the estimate of p derived from the
classification of the image.

p is unknown.

p_hat_hum is derived from human interpretation of google earth
imagery.  If the value is determined by hand digitizing the entire
region, we will assume it was done perfectly and so p_hat_hum = p.
However, because some of the areas that we will assess will be quite
large and hand digitizing may take too much time, we will use random
points to calculate p_hat_hum.  For example, if the area that we want
to calculate accuracy at is 100 m^2, we'll place n points randomly in
this area and determine the cover below them.  Using the normal
approximation, the variance for p_hat_hum is
(p_hat_hum*(1-p_hat_hum)/n).  Which is at most .25/n.

p_hat_map is derived from the classified imagery.  Given the area of
interested, p_hat_map is the proportion of pixels in that area
classified as tree canopy cover.

* Hypothesis

Does the difference between p and p_hat_map (that is the error of the
map), decrease as the area under consideration increases?

Substitute p_hat_hum for p, since we don't know it, and write in
symbols.

H_o: (p_hat_map_small - p_hat_hum_small) > (p_hat_map_large - p_hat_hum_large)
H_a: (p_hat_map_small - p_hat_hum_small) !> (p_hat_map_large - p_hat_hum_large)

or

H_o: (p_hat_map_small - p_hat_hum_small) - (p_hat_map_large -
p_hat_hum_large) > 0
H_a: (p_hat_map_small - p_hat_hum_small) - (p_hat_map_large -
p_hat_hum_large) !> 0

where p_hat_map_small is the mean p_hat_map over m locations of size
"small", and p_hat_map_large is the mean p_hat_map over m locations of
size "large".  Each small region is nested within a large region,
making their estimates dependent.

Above I only used two sizes, "small" and "large", but I will probably
test 4 or 5 sizes and do pairwise tests for significant differences.

* Simulations to determine what sampling plan will be sufficient to address my hypothesis.

** functions
#+begin_src R
  fortifyMerge = function(shapes.sp, col="id") {
      shapes.sp@data[,col] = rownames(shapes.sp@data)
      shapes.df = fortify(shapes.sp)
      shapes.df = merge(shapes.df, shapes.sp@data, by=col, all.x=TRUE)
      return(shapes.df)
  }

  make.true.tree.cover.realization <- function(stem.density,
                                               mean.crown.dia) {

      x.min = 0
      x.max = 100
      y.min = 0
      y.max = 100

                                          # generate derived variables
      region_area <- (x.max-x.min)*(y.max-y.min)

                                          # generate number of stems
      n.stems <- rpois(n = 1, lambda = region_area * stem.density)

                                          # generate locations of stems
      x <- runif(n = n.stems, min = x.min, max = x.max)
      y <- runif(n = n.stems, min = y.min, max = y.max)

                                          # make stems sp object
      xy <- data.frame(x,y)
      xy.sp <- SpatialPoints(xy)

      diameters <- vector(length = length(xy.sp)) #vector to save diameters of trees created
      xy.pol <- foreach(i = 1:length(xy.sp)) %do% {
                                          # https://stat.ethz.ch/pipermail/r-help/2005-May/070678.html
          U <- runif(1)
          t <- -log(1- U*(1-exp(-mean.crown.dia)))
          T1<-(mean.crown.dia - t)
          dia <- rpois(n = 1, lambda = T1)+1
          diameters[i] <- dia
          pol <- gBuffer(xy.sp[i,], width = dia)
          pol <- spChFIDs(pol, x = as.character(i))
      }

      pol <- do.call("rbind", xy.pol)

      tree.sp <- gUnionCascaded(pol)

      out.list <- list(tree.cover.sp = tree.sp, diameters = diameters, pt.sp = xy.sp)
      return(out.list)
  }

  make.pseudo.classification <- function(pts,
                                         diameters,
                                         h_shift = T,
                                         horizontal_shift_mean = 2,
                                         lean = T,
                                         interior.error.rate = .05,
                                         additional.boundary.error.rate = .15) {

      if(h_shift == T) {
                                          # draw horizontal shift from exponential distribution with mean horizontal_shift_mean
          lambda = 1/horizontal_shift_mean
          d <- rexp(n = 1, rate = lambda)
          direction.radian <- runif(n = 1, min = 0, max = 2*pi)
          x.shift <- d * cos(direction.radian)
          y.shift <- d * sin(direction.radian)

          x <- coordinates(pts)[,1] + x.shift
          y <- coordinates(pts)[,2] + y.shift

          pts <- SpatialPoints(cbind(x,y))
      }

                                          # Assign lean based on random draw from uniform distribution to determine east/west, and distance from image center
      if(lean == T) {
          num <- length(pts)
          east.west <- sample(c(1,-1), size = 1, replace = T)
          dist.to.center <- runif(0,6000, n = 1) #width of flightline is about 12km

          lean <- function(east.west, height, dist.to.center) {
              d = height / (9000/dist.to.center)
              d <- d*east.west
              return(d)
          }

          lean.dist <- lean(east.west, diameters, dist.to.center)

          x <-  coordinates(pts)[,1] + lean.dist
          y <- coordinates(pts)[,2]

          pts <- SpatialPoints(cbind(x,y))
      }

      xy.pol <- foreach(i = 1:length(pts)) %do% {
          pol <- gBuffer(pts[i,], width = diameters[i])
          pol <- spChFIDs(pol, x = as.character(i))
      }

      pol <- do.call("rbind", xy.pol)

      tree.sp <- gUnionCascaded(pol)

                                          # rasterize polygon to NAIP imagery resolution
      r <- raster(extent(bbox(tree.sp)),nrows = 100, ncols = 100)
      values(r) <- 0

      tree.r <- rasterize(tree.sp, r)

                                          # "classify" image with overall error, and additional error at boundaries of tree cover
      bound <- boundaries(tree.r, classes = T)

      tree <- tree.r

      tree[is.na(tree)] <- -1

      rand <- runif(ncell(tree))

      rand.raster <- raster(tree)
      values(rand.raster) <- runif(ncell(rand.raster))

      acc.raster <- raster(tree)
      values(acc.raster) <- 1
      acc.raster[bound == 1] <- acc.raster[bound == 1] - additional.boundary.error.rate
      acc.raster <- acc.raster - interior.error.rate

      acc.raster <- acc.raster > rand.raster

      classified.tree <- overlay(tree, acc.raster, fun=function(x,y){ifelse(y==T, x*1,x*-1)})

      out <- list(classified.cover = classified.tree, tree.raster = tree.r, points = pts)
      return(out)
  }


make.class.trueCover.agreement.df <- function(replicate,
                                              stem.density = .01,
                                              mean.crown.dia = 5,
                                              h_shift_mean = 2,
                                              interior.error.rate = .05,
                                              additional.boundary.error.rate = .15) {


    true.tree.cover.realization <- make.true.tree.cover.realization(stem.density,
                                                                    mean.crown.dia)

pseudo.classification <- make.pseudo.classification(true.tree.cover.realization$pt.sp,
                                                    true.tree.cover.realization$diameters,
                                                    h_shift = T,
                                                    horizontal_shift_mean = h_shift_mean,
                                                    lean = T,
                                                    interior.error.rate,
                                                    additional.boundary.error.rate)


pt <- SpatialPoints(matrix(c(50,50),nrow = 1))
radii <- seq(1,50,3)

circles <- lapply(radii, function(radius) as(gBuffer(pt, width = radius), "SpatialPolygonsDataFrame")) %>%
    unlist()

pct.tree.classification <- lapply(circles, function(circle) {
    values <- extract(pseudo.classification$classified.cover, circle) %>% unlist()
    pct.tree.classification <- sum(values == 1)/length(values)
    pct.tree.classification
}
) %>%
    unlist()

pct.tree.true <- lapply(circles, function(circle) {
    pct.tree.true <- gArea(crop(true.tree.cover.realization$tree.cover.sp, circle))/gArea(circle)
}) %>%
    unlist()

agreement.df <- data.frame(pct.tree.true = pct.tree.true,
                           pct.tree.classification = pct.tree.classification,
                           error = abs(pct.tree.true - pct.tree.classification),
                           radius = radii,
                           area = round(radii^2*pi),
                           horizontal_shift_mean = h_shift_mean,
                           interior.error.rate = interior.error.rate,
                           additional.boundary.error.rate = additional.boundary.error.rate,
                           replicate = replicate
                           )
return(list(agreement.df, true.tree.cover.realization, pseudo.classification))
}


#+end_src

#+RESULTS:

** Consider some real location with tree cover
#+begin_src R
  library(raster)
  library(plyr)
  library(sp)
  library(foreach)
  library(rgeos)
  library(ggplot2)
  library(dplyr)

  x.min = 0
  x.max = 100
  y.min = 0
  y.max = 100
  stem.density = .01 # average number of stems per unit area
  mean.crown.dia = 5
                                          # generate derived variables
  region_area <- (x.max-x.min)*(y.max-y.min)

                                          # generate number of stems

  n.stems <- rpois(n = 1, lambda = region_area * stem.density)


                                          # generate locations of stems

  x <- runif(n = n.stems, min = x.min, max = x.max)
  y <- runif(n = n.stems, min = y.min, max = y.max)


                                          # make stems sp object
  xy <- data.frame(x,y)
  xy.sp <- SpatialPoints(xy)
#+end_src

#+RESULTS:


#+begin_src R :exports results :results graphics :file ../figs/stems.png
  plot(xy.sp)
#+end_src

#+RESULTS:
[[file:../figs/stems.png]]

#+begin_src R
                                          # add crown to stems
  diameters <- vector(length = length(xy.sp)) #vector to save diameters of trees created
  xy.pol <- foreach(i = 1:length(xy.sp)) %do% {
                                          # https://stat.ethz.ch/pipermail/r-help/2005-May/070678.html
      U <- runif(1)
      t <- -log(1- U*(1-exp(-mean.crown.dia)))
      T1<-(mean.crown.dia - t)
      dia <- rpois(n = 1, lambda = T1)+1
      diameters[i] <- dia
      pol <- gBuffer(xy.sp[i,], width = dia)
      pol <- spChFIDs(pol, x = as.character(i))
  }

  pol <- do.call("rbind", xy.pol)

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/stems_wCrowns.png
  plot(pol)
#+end_src

#+RESULTS:
[[file:../figs/stems_wCrowns.png]]
#+begin_src R
                                          # create tree spatial polygon
  tree.sp <- gUnionCascaded(pol)

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/crowns_merged.png
  #  plot(tree.sp)
    tree.sp.fort <- fortify(tree.sp) %>%
        dplyr::rename(x = long, y = lat) %>%
        mutate(canopy_cover = "true")

    true_canopy <- ggplot() +
        geom_polygon(data = tree.sp.fort[tree.sp.fort$id %in% tree.sp.fort[tree.sp.fort$hole,]$id,], aes(group = group, x = x, y = y, fill = canopy_cover)) +
        coord_equal() +
        scale_fill_manual(values = "#7fc97f")

true_canopy
#+end_src

#+RESULTS:
[[file:../figs/crowns_merged.png]]

** Consider what that real location might look like in NAIP
NAIP has pretty good horizontal accuracy.  I think around 95 or 98% of
reference points are less than 6m from point in image.  And in 08 or
09 imagery from Indiana, the mean horizontal error is around 2 m.
This is what I see in the NAIP imagery over madison, pretty small
errors.

This misregistration error is lower bound by zero, and has mean of 2 and
95 quantile of 6.  Maybe it has an exponential distribution?  I tried
looking up data on the accuracy assessment of NAIP imagery, but
couldn't find anything on the distribution of error or the raw data.

#+begin_src R
mean <- 2
lambda <- 1/mean
qexp(p = .95, rate = lambda, lower.tail = T)
#+end_src

#+RESULTS:
: [1] 5.991465

The 95% quantile of an exponential distribution with mean 2 is
about 6. It seems like the exponential distribution may work well
enough for the horizontal shift in a scene.

*** Shift canopy cover by a distance D ~ Exp( \lambda = 1/2)
#+begin_src R
  d <- rexp(n = 1, rate = .5)
  direction.radian <- runif(n = 1, min = 0, max = 2*pi)
  x.shift <- d * cos(direction.radian)
  y.shift <- d * sin(direction.radian)

  x <- coordinates(xy.sp)[,1] + x.shift
  y <- coordinates(xy.sp)[,2] + y.shift

  xy.sp.hshift <- SpatialPoints(cbind(x,y))
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/pts_hshift.png
xy.sp.df <- as.data.frame(xy.sp) %>% mutate(stems = "true location")
xy.sp.hshift.df <- as.data.frame(xy.sp.hshift) %>% mutate(stems = "horizontal shift")
df <- rbind(xy.sp.df, xy.sp.hshift.df)
ggplot(df, aes(x = x, y = y, color = stems)) + geom_point()
#+end_src

#+RESULTS:
[[file:../figs/pts_hshift.png]]

*** "Leaning Tree"  Parallax issues
Objects with height are shifted in the imagery away from the center of
the image.  NAIP is orthorectified with a digital elevation model and
I think in the direction of the plane's flight, but there isn't
sufficient overlap to create true orthophotos - hence this leaning
tree problem.  Flights were generally north-south, so trees are
shifted in the image towards the east or west.  The amount of shift
depends on the height of the tree and the distance from the center of
the image.  I'm not sure what the distribution of the shifts will be.

elevation = 9000 m is the altitude of plane collecting imagery
field of view is 64 degrees
dist.to.center = distance to point on ground nadir to plane (center of
image)
h = height of object on ground
d = distance the top of that object will be shifted in the image
relative to its true location

elevation/dist.to.center = height/d

d =  height / (elevation/dist.to.center)

#+begin_src R

  num <- length(xy.sp.hshift)
    east.west <- sample(c(1,-1), size = 1, replace = T)
    dist.to.center <- runif(0,6000, n = 1) #width of flightline is about 12km

    lean <- function(east.west, height, dist.to.center) {
        d = height / (9000/dist.to.center)
        d <- d*east.west
        return(d)
    }

  lean.dist <- lean(east.west, diameters, dist.to.center)

x <- x + lean.dist

xy.sp.leanshift <- SpatialPoints(cbind(x,y))

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/stems_lean_shift.png
xy.sp.leanshift.df <- as.data.frame(xy.sp.leanshift) %>% mutate(stems = "parallax/lean shift")
df <- rbind(df, xy.sp.leanshift.df)
ggplot(df, aes(x = x, y = y, color = stems)) + geom_point()
#+end_src

#+RESULTS:
[[file:../figs/stems_lean_shift.png]]

#+begin_src R :exports results :results graphics :file ../figs/shifted_canopy.png

        xy.pol <- foreach(i = 1:length(xy.sp.leanshift)) %do% {
          pol <- gBuffer(xy.sp.leanshift[i,], width = diameters[i])
          pol <- spChFIDs(pol, x = as.character(i))
        }

        pol.shift <- do.call("rbind", xy.pol)
      #  plot(pol.shift)

        tree.sp.shift <- gUnionCascaded(pol.shift)
     #   plot(tree.sp.shift)



        tree.sp.fort.shift <- fortify(tree.sp.shift) %>%
            dplyr::rename(x = long, y = lat) %>%
            mutate(canopy_cover = "shifted",
                   group = paste0(group,canopy_cover))

    df <- rbind(tree.sp.fort.shift, tree.sp.fort)

        canopy <- ggplot() +
            geom_polygon(data = df[df$id %in% df[df$hole,]$id,], aes(group = group, x = x, y = y, color = canopy_cover),fill = NA) +
            coord_equal() +
            scale_color_manual(values = c("#00a08a","black")) +
            theme_bw()
    canopy

#+end_src

#+RESULTS:
[[file:../figs/shifted_canopy.png]]

** Rasterize what NAIP images
#+begin_src R
  r <- raster(extent(bbox(tree.sp.shift)),nrows = 100, ncols = 100)
  values(r) <- 0

  tree.r.shift <- rasterize(tree.sp.shift, r)
  plot(tree.r.shift)
  tree.r.shift.df <- as.data.frame(tree.r.shift, xy=T)

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/pseudoNAIP.png

  r.plot <- ggplot() +  geom_raster(data = tree.r.shift.df, aes(x = x, y = y, fill = layer)) + theme_bw() +
      scale_fill_continuous(high = "#7fc97f", na.value = "white") +
coord_equal()

  r.plot
#+End_src

#+RESULTS:
[[file:../figs/pseudoNAIP.png]]

** Create a pseudoclassifier that has a certain amount of error built in.

greater error at boundaries

#+begin_src R
      interior.error.rate <- .05
      additional.boundary.error.rate <- .15

      bound <- boundaries(tree.r.shift, classes = T)

    tree <- tree.r.shift

      tree[is.na(tree)] <- -1

      rand <- runif(ncell(tree))

      rand.raster <- raster(tree)
      values(rand.raster) <- runif(ncell(rand.raster))

      acc.raster <- raster(tree)
      values(acc.raster) <- 1
      acc.raster[bound == 1] <- acc.raster[bound == 1] - additional.boundary.error.rate
      acc.raster <- acc.raster - interior.error.rate

      acc.raster <- acc.raster > rand.raster

      classified.tree <- overlay(tree, acc.raster, fun=function(x,y){ifelse(y==T, x*1,x*-1)})


  #    plot(classified.tree)

      classified.tree.df <- as.data.frame(classified.tree, xy = T) %>%
        mutate(layer = plyr::mapvalues(layer, from = c(1,-1), to = c("t","o")))

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/pseudoClassified.png

  pseudo.class <- ggplot(classified.tree.df, aes(x = x, y = y, fill = layer)) + geom_raster() +
    utc.fill

pseudo.class
#+end_src

#+RESULTS:
[[file:../figs/pseudoClassified.png]]

** Test how agreement between True Canopy Cover and the pseudoclassification changes as scale increases
#+begin_src R
        pt <- SpatialPoints(matrix(c(50,50),nrow = 1))
        radii <- seq(1,50,3)

    circles <- lapply(radii, function(radius) as(gBuffer(pt, width = radius), "SpatialPolygonsDataFrame")) %>%
        unlist()

      pct.tree.classification <- lapply(circles, function(circle) {
          values <- extract(classified.tree, circle) %>% unlist()
          pct.tree.classification <- sum(values == 1)/length(values)
          pct.tree.classification
      }
    ) %>%
unlist()

  pct.tree.true <- lapply(circles, function(circle) {
      pct.tree.true <- gArea(crop(tree.sp, circle))/gArea(circle)
  }) %>%
unlist()

agreement.df <- data.frame(error = pct.tree.true - pct.tree.classification, radius = radii)
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/agreementBYradius_n1.png
ggplot(agreement.df, aes(x = radius, y = error)) + geom_point()
#+end_src

#+RESULTS:
[[file:../figs/agreementBYradius_n1.png]]

** Replicate above test many times
code below is copied much from above.

#+begin_src R
  library(doParallel)

    x.min = 0
    x.max = 100
    y.min = 0
    y.max = 100

    stem.density = .01 # average number of stems per unit area
    mean.crown.dia = 5
    h_shift_mean = 2
    interior.error.rate = .05
    additional.boundary.error.rate = .15


  cl <- makeCluster(detectCores())
  registerDoParallel(cl)


  replication <- foreach(j = 1:3, .packages = c("plyr","dplyr","rgeos","sp","doParallel","foreach","raster")) %dopar% {
      make.class.trueCover.agreement.df(replicate = j)
  }

  closeAllConnections()


  dfs <- lapply(replication, function(rep) rep[[1]])

  dfs <- bind_rows(dfs)
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/errorVSarea_TrueAndExactClass.png
ggplot(dfs, aes(x = area, y = error, color = replicate, group = replicate)) + geom_line()
#+end_src

#+RESULTS:
[[file:../figs/errorVSarea_TrueAndExactClass.png]]


#+begin_src R

    lapply(replication, function(rep) {

        class.ras <- as.data.frame(rep[[3]]$classified.cover, xy = T) %>%
            mutate(classified.cover = mapvalues(layer, from = c(-1,1), to = c("o","t")))

        class.ras.gg <-  geom_raster(data = class.ras, aes(x = x, y = y, fill = classified.cover))

        true.tree <- fortify(rep[[2]]$tree.cover.sp) %>%
            dplyr::rename(x = long, y = lat) %>%
            mutate(actual.cover = "t")

        true.tree.gg <- geom_polygon(data = true.tree, aes(x = x, y = y, group = group, color = actual.cover), fill = "black",alpha = .3)

        ggplot() +
            coord_equal() +
            class.ras.gg +
            true.tree.gg +
            utc.fill +
            utc.col

  })


#+end_src

#+RESULTS:
:  Error in plot.window(...) (from #2) : need finite 'xlim' values
: In addition: Warning messages:
: 1: In min(x) : no non-missing arguments to min; returning Inf
: 2: In max(x) : no non-missing arguments to max; returning -Inf
: 3: In min(x) : no non-missing arguments to min; returning Inf
: 4: In max(x) : no non-missing arguments to max; returning -Inf

** Create Accuracy Assessment points

1) Single points (really 1m^2 boxes)
2) circles of increasing radii with n randomly located points in them
3) squares of increasing size with n randomly located points in them

I create the largest radius region first, and create random points.
Those random points that fall within the smaller regions get reused
there and I create new points in the smaller regions to get the the
same number of points that I had in the larger region.  This creates
dependence, but may save on the number of points a person needs to identify.

#+begin_src R

  pt <- SpatialPoints(matrix(c(50,50),nrow = 1))

  pt.cir <- gBuffer(pt,width = .5, quadsegs = 5)

  plot(pt.cir)

#+end_src

#+RESULTS:

#+begin_src R
  spsample.exact <- function(x, exact.n, type, ...) {
      exact.n <- round(exact.n)
      sp <- spsample(x, n = exact.n, type)
      while (length(sp) != exact.n) {
          sp <- spsample(x, n = exact.n, type)
      }
      return(sp)
  }


  AddHoleToPolygon <-function(poly,hole){
      # invert the coordinates for Polygons to flag it as a hole
      coordsHole <-  hole@polygons[[1]]@Polygons[[1]]@coords
      newHole <- Polygon(coordsHole,hole=TRUE)

      # punch the hole in the main poly
      listPol <- poly@polygons[[1]]@Polygons
      listPol[[length(listPol)+1]] <- newHole
      punch <- Polygons(listPol,poly@polygons[[1]]@ID)

      # make the polygon a SpatialPolygonsDataFrame as the entry
      new <- SpatialPolygons(list(punch),proj4string=poly@proj4string)
      new <- SpatialPolygonsDataFrame(new,data=as(poly,"data.frame"))

      return(new)
  }

  n <- 100
  sampling.type = "random"

  radii <- c(10,20,30) # must be increasing

  circles <- lapply(radii, function(radius) as(gBuffer(pt, width = radius), "SpatialPolygonsDataFrame"))

  pts.list <- list()

  for(i in 1:length(radii)) {
      if(i == 1) {
          pts <- spsample.exact(circles[[i]], exact.n = n, type = sampling.type)
        pts <- SpatialPointsDataFrame(pts, data = data.frame(radius = rep(radii[i],n)))
      }
      if (i > 1) {
          area.ratio.small.large <- gArea(circles[[i-1]])/gArea(circles[[i]])
          ring <- AddHoleToPolygon(circles[[i]],circles[[i-1]])
          pts.sub <- pts.list[[i-1]][sample(length(pts.list[[i-1]]), round(n*area.ratio.small.large)),]
          pts.add <- spsample.exact(ring, exact.n = n*(1-area.ratio.small.large), type = sampling.type)
          pts <- bind(pts.add, pts.sub)
          pts <- SpatialPointsDataFrame(pts, data = data.frame(radius= rep(radii[i],length(pts))))
      }
          pts.list[[i]] <- pts
  }

  pts <- do.call("bind", pts.list)


#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file ../figs/acc_pts.png
  pts.df <- data.frame(pts) %>%
    arrange(-radius)
  ggplot(pts.df, aes(x = x, y = y, color = factor(radius), size = radius)) + geom_point(alpha = .8) +
coord_equal()

#+end_src

#+RESULTS:
[[file:../figs/acc_pts.png]]
But really the points are small areas in which I assess cover.
#+begin_src R

m.polys <- gBuffer(pts, width = .5, byid = T)

#+end_src

#+RESULTS:


#+begin_src R :exports results :results graphics :file ../figs/1m_acc.png

      m.polys.df <- fortifyMerge(m.polys) %>%
        dplyr::rename(x = long, y = lat)



  points_1mpolys <- geom_polygon(data = m.polys.df, aes(x = x, y = y, group = group, color = radius), fill = NA)


  ggplot() + points_1mpolys +
        coord_equal()

#+end_src

#+RESULTS:
[[file:../figs/1m_acc.png]]

#+begin_src R :exports results :results graphics :file ../figs/points_class.png
pseudo.class + points_1mpolys
#+end_src

#+RESULTS:
[[file:../figs/points_class.png]]
#+begin_src R :exports results :results graphics :file ../figs/points_canopy.png
true_canopy + points_1mpolys
#+end_src

#+RESULTS:
[[file:../figs/points_canopy.png]]

